    /* bool runOnFunction(Function &F) override { */
    /*   errs() << "Function CudaAnalysis: "; */
    /*   errs().write_escaped(F.getName()) << '\n'; */
    /*   for (auto &BB: F) { */
    /*     for (auto &I : BB) { */
    /*       if (auto *CI = dyn_cast<CallInst>(&I)) { */
    /*         auto *Callee = CI->getCalledFunction(); */
    /*         if (Callee && Callee->getName() == "cudaMalloc") { */
    /*           errs() << "found a cudaMalloc\n"; */
    /*           auto *AllocPtr = CI->getArgOperand(0); */
    /*           AllocPtr->dump(); */
    /*         } */
    /*         if (Callee && Callee->getName() == "cudaLaunchKernel") { */
    /*           errs() << "found a cudaLaunchKernel\n"; */
    /*           auto *AllocPtr = CI->getArgOperand(5); */
    /*           AllocPtr->dump(); */
    /*           for (User *U: AllocPtr->users()) { */
    /*             if(Instruction *Inst = dyn_cast<Instruction>(U)) { */
    /*               Inst->dump(); */
    /*             } */
    /*           } */
    /*         } */
    /*       } */
    /*     } */
    /*   } */



    /* for (auto &BB: F) { */
    /*   for (auto &I : BB) { */
    /*     if (auto *LI = dyn_cast<LoadInst>(&I)) { */
    /*       LI->dump(); */
    /*       for (Use &U: LI->operands()){ */
    /*         U->dump(); */
    /*         if (auto G = dyn_cast<GetElementPtrInst>(U)) { */
    /*           errs() << "found GEP\n"; */
    /*           PointerInfoMap[G->getPointerOperand()]++; */
    /*         } */
    /*       } */
    /*     } else if (auto *SI = dyn_cast<StoreInst>(&I)) { */
    /*       SI->dump(); */
    /*       for (Use &U: SI->operands()){ */
    /*         U->dump(); */
    /*         if (auto G = dyn_cast<GetElementPtrInst>(U)) { */
    /*           errs() << "found GEP\n"; */
    /*           PointerInfoMap[G->getPointerOperand()]++; */
    /*         } */
    /*       } */
    /*     } */
    /*   } */
    /* } */

    /* for (auto &BB: F) { */
    /*   for (auto &I : BB) { */
    /*     /1* if (auto *CI = dyn_cast<CallInst>(&I)) { *1/ */
    /*     /1* IsSpecialRegisterRead(CI); *1/ */
    /*     /1* } *1/ */
    /*     if (auto *LI = dyn_cast<LoadInst>(&I)) { */
    /*       /1* LI->dump(); *1/ */
    /*     } else if (auto *SI = dyn_cast<StoreInst>(&I)) { */
    /*       /1* SI->dump(); *1/ */
    /*       for (Use &U: SI->operands()){ */
    /*         /1* U->dump(); *1/ */
    /*         if (auto G = dyn_cast<GetElementPtrInst>(U)) { */
    /*           errs() << "found GEP\n"; */
    /*           G->dump(); */
    /*           PrintBack(G); */
    /*         } */
    /*       } */
    /*     } */
    /*   } */
    /* } */

      for (LoopInfo::iterator lii = LI.begin(); lii != LI.end(); ++lii) {
        errs() << "\nLOOP \n" << *lii << "\n";
        /* (*lii)->dump(); */
        errs() << (*lii) << "\n";
        Loop &root = *(*lii);
        auto loopnest = new LoopNest(root, SE);
        errs() << "num loops = " << loopnest->getNumLoops() << "\n";
        errs() << "depth loops = " << loopnest->getNestDepth() << "\n";
        auto loops = loopnest->getLoops();
        for (auto li = loops.begin(); li != loops.end(); li++) {
          (*li)->dump();
          errs() << "is canonical " << ((*li)->isCanonical(SE)) << "\n";
          errs() << "loop details " << (*li) << "\n";
          auto loopbounds = (*li)->getBounds(SE);
          if (loopbounds) {
            loopbounds->getInitialIVValue().dump();
            loopbounds->getStepValue()->dump();
            loopbounds->getFinalIVValue().dump();
            // unsigned long long int initial = dyn_cast<ConstantInt> (loopbounds.value().getInitialIVValue()).getSExtValue();
            // unsigned long long int final = dyn_cast<ConstantInt> (loopbounds.value().getFinalIVValue()).getSExtValue();
            // unsigned long long int step = dyn_cast<ConstantInt> (loopbounds.value().getStepValue()).getSExtValue();
            // unsigned long long int iters = (final - initial) / step;
            // errs() << "iters = " << iters << "\n";
            // LoopToIterMapping[(*li)] = dyn_cast<ConstantInt> (loopbounds.value().getFinalIVValue()).getSExtValue();
          }
          auto loopBlocks = (*li)->blocks();
          for (auto &BB : loopBlocks) {
            for (BasicBlock::iterator ii = BB->begin(); ii != BB->end(); ii++) {
              Instruction &I = *ii;
              if (auto *LdI = dyn_cast<LoadInst>(&I)) {
                // LdI->dump();
              } else if (auto *StI = dyn_cast<StoreInst>(&I)) {
                // StI->dump();
              }
              if (auto G = dyn_cast<GetElementPtrInst>(&I)) {
                // G->dump();
                // G->getParent()->dump();
                errs() << "basic block " << G->getParent()->getName() << "\n";
                errs() << "basic block " << G->getParent() << "\n";
                errs() << "loop is " << LI.getLoopFor(G->getParent()) << "\n";
                if ((*li) != LI.getLoopFor(G->getParent())) {
                  errs() << "not match\n";
                  continue;
                }
                Loop *loop = LI.getLoopFor(G->getParent());
                Optional<Loop::LoopBounds> thisloopbounds = loop->getBounds(SE);
                int iters = 0;
                // if (thisloopbounds) {
                //   Loop::LoopBounds &lpb = thisloopbounds.value();
                //   Value &VIters = lpb.getFinalIVValue();
                //   // VIters.dump();
                //   ConstantInt *CIters = dyn_cast<ConstantInt>(&VIters);
                //   iters = CIters->getSExtValue();
                //   errs() << "iters " << iters << "\n";
                // }
                PointerInfoMap[G->getPointerOperand()] += iters;
              }
            }
          }
        }
        errs() << " info\n";
        for (auto i = PointerInfoMap.begin(); i != PointerInfoMap.end(); i++) {
          i->first->dump();
          errs() << "Count  " << i->second << "\n";
        }
        // ICmpInst* cmpinst = (*lii)->getLatchCmpInst();
        // cmpinst->dump();
      }

        // ICmpInst* cmpinst = (*lii)->getLatchCmpInst();
        // cmpinst->dump();
      }

      return false;
